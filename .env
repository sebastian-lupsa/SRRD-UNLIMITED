workflow-backend/
├─ package.json
├─ .env              # create this file locally
├─ src/
│  ├─ server.js
│  ├─ db.js
│  ├─ app.js
│  ├─ middleware/
│  │  └─ auth.js
│  ├─ models/
│  │  ├─ users.js
│  │  ├─ invoices.js
│  │  └─ logs.js
│  ├─ controllers/
│  │  ├─ authController.js
│  │  ├─ invoiceController.js
│  │  └─ reportController.js
│  └─ routes/
│     ├─ authRoutes.js
│     ├─ invoiceRoutes.js
│     └─ reportRoutes.js
└─ sql/
   └─ schema.sql
{
  "name": "workflow-backend",
  "version": "1.0.0",
  "type": "module",
  "main": "src/server.js",
  "scripts": {
    "dev": "NODE_ENV=development nodemon src/server.js",
    "start": "node src/server.js",
    "db:migrate": "psql \"$DB_URL\" -f sql/schema.sql"
  },
  "dependencies": {
    "bcryptjs": "2.4.3",
    "cors": "2.8.5",
    "dotenv": "16.4.5",
    "express": "4.21.1",
    "helmet": "7.0.0",
    "jsonwebtoken": "9.0.2",
    "morgan": "1.10.0",
    "pg": "8.13.0"
  },
  "devDependencies": {
    "nodemon": "3.1.7"
  }
}NODE_ENV=development
PORT=4000

# PostgreSQL (choose one style)
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_DATABASE=workflow_mvp

# Or a single URL if you prefer:
# DB_URL=postgres://postgres:postgres@localhost:5432/workflow_mvp

JWT_SECRET=replace-with-a-long-random-string
JWT_EXPIRES=7d
Backend MVP for workflow automation (Express + PostgreSQL)
Below is a ready-to-run backend skeleton with authentication, database models, and the four core routes. Copy the files into your project, run the install step, configure .env, then start the server.

Project structure
workflow-backend/
├─ package.json
├─ .env              # create this file locally
├─ src/
│  ├─ server.js
│  ├─ db.js
│  ├─ app.js
│  ├─ middleware/
│  │  └─ auth.js
│  ├─ models/
│  │  ├─ users.js
│  │  ├─ invoices.js
│  │  └─ logs.js
│  ├─ controllers/
│  │  ├─ authController.js
│  │  ├─ invoiceController.js
│  │  └─ reportController.js
│  └─ routes/
│     ├─ authRoutes.js
│     ├─ invoiceRoutes.js
│     └─ reportRoutes.js
└─ sql/
   └─ schema.sql



Installation and scripts
{
  "name": "workflow-backend",
  "version": "1.0.0",
  "type": "module",
  "main": "src/server.js",
  "scripts": {
    "dev": "NODE_ENV=development nodemon src/server.js",
    "start": "node src/server.js",
    "db:migrate": "psql \"$DB_URL\" -f sql/schema.sql"
  },
  "dependencies": {
    "bcryptjs": "2.4.3",
    "cors": "2.8.5",
    "dotenv": "16.4.5",
    "express": "4.21.1",
    "helmet": "7.0.0",
    "jsonwebtoken": "9.0.2",
    "morgan": "1.10.0",
    "pg": "8.13.0"
  },
  "devDependencies": {
    "nodemon": "3.1.7"
  }
}



Environment variables
Create .env in the project root:
NODE_ENV=development
PORT=4000

# PostgreSQL (choose one style)
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_DATABASE=workflow_mvp

# Or a single URL if you prefer:
# DB_URL=postgres://postgres:postgres@localhost:5432/workflow_mvp

JWT_SECRET=replace-with-a-long-random-string
JWT_EXPIRES=7d



Database schema
sql/schema.sql
CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(120) NOT NULL,
  email VARCHAR(160) UNIQUE NOT NULL,
  password_hash VARCHAR(200) NOT NULL,
  role VARCHAR(40) NOT NULL DEFAULT 'employee', -- employee | manager | finance | admin
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS invoices (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  amount NUMERIC(12,2) NOT NULL,
  currency VARCHAR(10) NOT NULL DEFAULT 'EUR',
  status VARCHAR(40) NOT NULL DEFAULT 'submitted', -- submitted | under_review | approved | rejected | paid
  approver_id INTEGER REFERENCES users(id),
  vendor VARCHAR(160),
  due_date DATE,
  note TEXT,
  file_url TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS logs (
  id SERIAL PRIMARY KEY,
  invoice_id INTEGER NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id),
  action VARCHAR(80) NOT NULL, -- created | validated | routed | approved | rejected | paid
  details TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);


Run migration:
- With DB_URL: npm run db:migrate
- Or execute the SQL in your local PostgreSQL client.

Database connection helper
src/db.js
import dotenv from 'dotenv';
import pkg from 'pg';
dotenv.config();

const { Pool } = pkg;

const pool = new Pool(
  process.env.DB_URL
    ? { connectionString: process.env.DB_URL }
    : {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_DATABASE
      }
);

pool.on('error', (err) => {
  console.error('Unexpected DB client error', err);
});

export const query = (text, params) => pool.query(text, params);
export default pool;



Express app bootstrap
src/app.js
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';

import authRoutes from './routes/authRoutes.js';
import invoiceRoutes from './routes/invoiceRoutes.js';
import reportRoutes from './routes/reportRoutes.js';

const app = express();

app.use(helmet());
app.use(cors({ origin: '*', credentials: false }));
app.use(express.json({ limit: '10mb' }));
app.use(morgan('dev'));

app.get('/health', (req, res) => res.json({ ok: true }));

app.use('/auth', authRoutes);
app.use('/invoices', invoiceRoutes);
app.use('/reports', reportRoutes);

app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(err.status || 500).json({ error: err.message || 'Server error' });
});

export default app;



Server entrypoint
src/server.js
import dotenv from 'dotenv';
dotenv.config();
import app from './app.js';

const port = process.env.PORT || 4000;

app.listen(port, () => {
  console.log(`API listening on http://localhost:${port}`);
});



JWT middleware
src/middleware/auth.js
import jwt from 'jsonwebtoken';

export const requireAuth = (roles = []) => {
  return (req, res, next) => {
    try {
      const header = req.headers.authorization || '';
      const token = header.startsWith('Bearer ') ? header.slice(7) : null;
      if (!token) return res.status(401).json({ error: 'Missing token' });

      const payload = jwt.verify(token, process.env.JWT_SECRET);
      req.user = payload;

      if (Array.isArray(roles) && roles.length > 0) {
        if (!roles.includes(req.user.role)) {
          return res.status(403).json({ error: 'Forbidden' });
        }
      }
      next();
    } catch (err) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  };
};



Models
src/models/users.js
import { query } from '../db.js';

export const findUserByEmail = async (email) => {
  const { rows } = await query('SELECT * FROM users WHERE email=$1', [email]);
  return rows[0] || null;
};

export const createUser = async ({ name, email, passwordHash, role = 'employee' }) => {
  const { rows } = await query(
    `INSERT INTO users (name, email, password_hash, role)
     VALUES ($1, $2, $3, $4)
     RETURNING id, name, email, role, created_at`,
    [name, email, passwordHash, role]
  );
  return rows[0];
};


src/models/invoices.js
import { query } from '../db.js';

export const createInvoice = async ({
  userId, amount, currency = 'EUR', vendor, dueDate, note, fileUrl
}) => {
  const { rows } = await query(
    `INSERT INTO invoices
     (user_id, amount, currency, status, vendor, due_date, note, file_url)
     VALUES ($1, $2, $3, 'submitted', $4, $5, $6, $7)
     RETURNING *`,
    [userId, amount, currency, vendor, dueDate, note, fileUrl]
  );
  return rows[0];
};

export const getInvoicesByUser = async (userId) => {
  const { rows } = await query(
    `SELECT * FROM invoices WHERE user_id=$1 ORDER BY created_at DESC`,
    [userId]
  );
  return rows;
};

export const getInvoiceById = async (id) => {
  const { rows } = await query(`SELECT * FROM invoices WHERE id=$1`, [id]);
  return rows[0] || null;
};

export const updateInvoiceStatus = async ({ id, status, approverId }) => {
  const { rows } = await query(
    `UPDATE invoices
     SET status=$2, approver_id=$3, updated_at=NOW()
     WHERE id=$1
     RETURNING *`,
    [id, status, approverId]
  );
  return rows[0] || null;
};


src/models/logs.js
import { query } from '../db.js';

export const addLog = async ({ invoiceId, userId, action, details }) => {
  const { rows } = await query(
    `INSERT INTO logs (invoice_id, user_id, action, details)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [invoiceId, userId, action, details]
  );
  return rows[0];
};

export const getLogsForInvoice = async (invoiceId) => {
  const { rows } = await query(
    `SELECT * FROM logs WHERE invoice_id=$1 ORDER BY created_at ASC`,
    [invoiceId]
  );
  return rows;
};



Controllers
src/controllers/authController.js
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { createUser, findUserByEmail } from '../models/users.js';

export const register = async (req, res) => {
  try {
    const { name, email, password, role = 'employee' } = req.body;
    if (!name || !email || !password) return res.status(400).json({ error: 'Missing fields' });

    const existing = await findUserByEmail(email);
    if (existing) return res.status(409).json({ error: 'Email already registered' });

    const passwordHash = await bcrypt.hash(password, 10);
    const user = await createUser({ name, email, passwordHash, role });

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role, name: user.name },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES || '7d' }
    );

    res.status(201).json({ token, user });
  } catch (err) {
    res.status(500).json({ error: 'Registration failed' });
  }
};

export const login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(401).json({ error: 'Invalid credentials' });

    const ok = await bcrypt.compare(password, user.password_hash);
    if (!ok) return res.status(401).json({ error: 'Invalid credentials' });

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role, name: user.name },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES || '7d' }
    );

    res.json({ token, user: { id: user.id, name: user.name, email: user.email, role: user.role } });
  } catch (err) {
    res.status(500).json({ error: 'Login failed' });
  }
};


src/controllers/invoiceController.js
import { addLog } from '../models/logs.js';
import { createInvoice, getInvoicesByUser, getInvoiceById, updateInvoiceStatus } from '../models/invoices.js';

const routeByAmount = (amount) => {
  // Basic routing rule for MVP:
  // < 5000 => manager; >= 5000 => finance
  if (Number(amount) < 5000) return 'manager';
  return 'finance';
};

export const uploadInvoice = async (req, res) => {
  try {
    const { amount, currency, vendor, dueDate, note, fileUrl } = req.body;
    if (!amount) return res.status(400).json({ error: 'Amount is required' });

    const invoice = await createInvoice({
      userId: req.user.id,
      amount,
      currency,
      vendor,
      dueDate,
      note,
      fileUrl
    });

    await addLog({
      invoiceId: invoice.id,
      userId: req.user.id,
      action: 'created',
      details: `Invoice created with amount ${invoice.amount} ${invoice.currency}`
    });

    const routeRole = routeByAmount(invoice.amount);
    await addLog({
      invoiceId: invoice.id,
      userId: req.user.id,
      action: 'routed',
      details: `Routed to ${routeRole}`
    });

    res.status(201).json({ invoice });
  } catch (err) {
    res.status(500).json({ error: 'Upload failed' });
  }
};

export const getStatus = async (req, res) => {
  try {
    const invoices = await getInvoicesByUser(req.user.id);
    res.json({ invoices });
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch status' });
  }
};

export const approveOrReject = async (req, res) => {
  try {
    const { invoiceId, decision } = req.body; // decision: 'approve' | 'reject'
    if (!invoiceId || !decision) return res.status(400).json({ error: 'Missing fields' });

    const invoice = await getInvoiceById(invoiceId);
    if (!invoice) return res.status(404).json({ error: 'Invoice not found' });

    // Simple role gate: manager can approve < 5000, finance can approve >= 5000
    const isManager = req.user.role === 'manager';
    const isFinance = req.user.role === 'finance';
    const amount = Number(invoice.amount);

    if (decision === 'approve') {
      if ((amount < 5000 && !isManager) || (amount >= 5000 && !isFinance)) {
        return res.status(403).json({ error: 'Insufficient privileges to approve' });
      }
      const updated = await updateInvoiceStatus({
        id: invoiceId,
        status: 'approved',
        approverId: req.user.id
      });
      await addLog({
        invoiceId,
        userId: req.user.id,
        action: 'approved',
        details: `Approved by ${req.user.role}`
      });
      return res.json({ invoice: updated });
    }

    if (decision === 'reject') {
      const updated = await updateInvoiceStatus({
        id: invoiceId,
        status: 'rejected',
        approverId: req.user.id
      });
      await addLog({
        invoiceId,
        userId: req.user.id,
        action: 'rejected',
        details: `Rejected by ${req.user.role}`
      });
      return res.json({ invoice: updated });
    }

    res.status(400).json({ error: 'Invalid decision' });
  } catch (err) {
    res.status(500).json({ error: 'Approval failed' });
  }
};


src/controllers/reportController.js
import { query } from '../db.js';

export const getBasicReport = async (req, res) => {
  try {
    const { rows: kpis } = await query(
      `SELECT
         COUNT(*) FILTER (WHERE status='submitted') AS submitted,
         COUNT(*) FILTER (WHERE status='approved') AS approved,
         COUNT(*) FILTER (WHERE status='rejected') AS rejected,
         AVG(EXTRACT(EPOCH FROM (updated_at - created_at)))/3600 AS avg_hours_to_update
       FROM invoices
       WHERE user_id=$1`,
      [req.user.id]
    );

    const { rows: blockers } = await query(
      `SELECT approver_id, COUNT(*) AS pending_count
       FROM invoices
       WHERE status='under_review' AND user_id=$1
       GROUP BY approver_id
       ORDER BY pending_count DESC
       LIMIT 5`,
      [req.user.id]
    );

    res.json({ kpis: kpis[0], blockers });
  } catch (err) {
    res.status(500).json({ error: 'Report failed' });
  }
};



Routes
src/routes/authRoutes.js
import { Router } from 'express';
import { login, register } from '../controllers/authController.js';

const router = Router();

router.post('/register', register);
router.post('/login', login);

export default router;


src/routes/invoiceRoutes.js
import { Router } from 'express';
import { requireAuth } from '../middleware/auth.js';
import { uploadInvoice, getStatus, approveOrReject } from '../controllers/invoiceController.js';

const router = Router();

// POST /upload
router.post('/upload', requireAuth(), uploadInvoice);

// GET /status
router.get('/status', requireAuth(), getStatus);

// POST /approve
router.post('/approve', requireAuth(['manager', 'finance']), approveOrReject);

export default router;


src/routes/reportRoutes.js
import { Router } from 'express';
import { requireAuth } from '../middleware/auth.js';
import { getBasicReport } from '../controllers/reportController.js';

const router = Router();

// GET /report
router.get('/report', requireAuth(), getBasicReport);

export default router;



Quick start
- Initialize and install:
- npm install
- Create .env with your DB and JWT settings.
- Create the database and run the migration:
- npm run db:migrate
- Start development:
- npm run dev
- Test requests:
- POST /auth/register → get a token
- POST /auth/login → get a token
- POST /invoices/upload (Bearer token)
- GET /invoices/status (Bearer token)
- POST /invoices/approve (Bearer token, role manager/finance)
- GET /reports/report (Bearer token)

Notes for production readiness
- Add input validation (e.g., zod or joi).
- Store files in S3 and save file_url from the S3 response.
- Add role-based routing rules configurable per tenant.
- Implement SSO later (SAML/OIDC) and per-tenant data isolation.
- Add rate limiting and robust error handling.

import dotenv from 'dotenv';
import pkg from 'pg';
dotenv.config();

const { Pool } = pkg;

const pool = new Pool(
  process.env.DB_URL
    ? { connectionString: process.env.DB_URL }
    : {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        user: process.env.DB_USER,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_DATABASE
      }
);

pool.on('error', (err) => {
  console.error('Unexpected DB client error', err);
});

export const query = (text, params) => pool.query(text, params);
export default pool;
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';

import authRoutes from './routes/authRoutes.js';
import invoiceRoutes from './routes/invoiceRoutes.js';
import reportRoutes from './routes/reportRoutes.js';

const app = express();

app.use(helmet());
app.use(cors({ origin: '*', credentials: false }));
app.use(express.json({ limit: '10mb' }));
app.use(morgan('dev'));

app.get('/health', (req, res) => res.json({ ok: true }));

app.use('/auth', authRoutes);
app.use('/invoices', invoiceRoutes);
app.use('/reports', reportRoutes);

app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(err.status || 500).json({ error: err.message || 'Server error' });
});

export default app;
import dotenv from 'dotenv';
dotenv.config();
import app from './app.js';

const port = process.env.PORT || 4000;

app.listen(port, () => {
  console.log(`API listening on http://localhost:${port}`);
});
import jwt from 'jsonwebtoken';

export const requireAuth = (roles = []) => {
  return (req, res, next) => {
    try {
      const header = req.headers.authorization || '';
      const token = header.startsWith('Bearer ') ? header.slice(7) : null;
      if (!token) return res.status(401).json({ error: 'Missing token' });

      const payload = jwt.verify(token, process.env.JWT_SECRET);
      req.user = payload;

      if (Array.isArray(roles) && roles.length > 0) {
        if (!roles.includes(req.user.role)) {
          return res.status(403).json({ error: 'Forbidden' });
        }
      }
      next();
    } catch (err) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  };
};
import { query } from '../db.js';

export const findUserByEmail = async (email) => {
  const { rows } = await query('SELECT * FROM users WHERE email=$1', [email]);
  return rows[0] || null;
};

export const createUser = async ({ name, email, passwordHash, role = 'employee' }) => {
  const { rows } = await query(
    `INSERT INTO users (name, email, password_hash, role)
     VALUES ($1, $2, $3, $4)
     RETURNING id, name, email, role, created_at`,
    [name, email, passwordHash, role]
  );
  return rows[0];
};
import { query } from '../db.js';

export const createInvoice = async ({
  userId, amount, currency = 'EUR', vendor, dueDate, note, fileUrl
}) => {
  const { rows } = await query(
    `INSERT INTO invoices
     (user_id, amount, currency, status, vendor, due_date, note, file_url)
     VALUES ($1, $2, $3, 'submitted', $4, $5, $6, $7)
     RETURNING *`,
    [userId, amount, currency, vendor, dueDate, note, fileUrl]
  );
  return rows[0];
};

export const getInvoicesByUser = async (userId) => {
  const { rows } = await query(
    `SELECT * FROM invoices WHERE user_id=$1 ORDER BY created_at DESC`,
    [userId]
  );
  return rows;
};

export const getInvoiceById = async (id) => {
  const { rows } = await query(`SELECT * FROM invoices WHERE id=$1`, [id]);
  return rows[0] || null;
};

export const updateInvoiceStatus = async ({ id, status, approverId }) => {
  const { rows } = await query(
    `UPDATE invoices
     SET status=$2, approver_id=$3, updated_at=NOW()
     WHERE id=$1
     RETURNING *`,
    [id, status, approverId]
  );
  return rows[0] || null;
};
import { query } from '../db.js';

export const addLog = async ({ invoiceId, userId, action, details }) => {
  const { rows } = await query(
    `INSERT INTO logs (invoice_id, user_id, action, details)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [invoiceId, userId, action, details]
  );
  return rows[0];
};

export const getLogsForInvoice = async (invoiceId) => {
  const { rows } = await query(
    `SELECT * FROM logs WHERE invoice_id=$1 ORDER BY created_at ASC`,
    [invoiceId]
  );
  return rows;
};
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { createUser, findUserByEmail } from '../models/users.js';

export const register = async (req, res) => {
  try {
    const { name, email, password, role = 'employee' } = req.body;
    if (!name || !email || !password) return res.status(400).json({ error: 'Missing fields' });

    const existing = await findUserByEmail(email);
    if (existing) return res.status(409).json({ error: 'Email already registered' });

    const passwordHash = await bcrypt.hash(password, 10);
    const user = await createUser({ name, email, passwordHash, role });

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role, name: user.name },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES || '7d' }
    );

    res.status(201).json({ token, user });
  } catch (err) {
    res.status(500).json({ error: 'Registration failed' });
  }
};

export const login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(401).json({ error: 'Invalid credentials' });

    const ok = await bcrypt.compare(password, user.password_hash);
    if (!ok) return res.status(401).json({ error: 'Invalid credentials' });

    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role, name: user.name },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRES || '7d' }
    );

    res.json({ token, user: { id: user.id, name: user.name, email: user.email, role: user.role } });
  } catch (err) {
    res.status(500).json({ error: 'Login failed' });
  }
};import { addLog } from '../models/logs.js';
import { createInvoice, getInvoicesByUser, getInvoiceById, updateInvoiceStatus } from '../models/invoices.js';

const routeByAmount = (amount) => {
  // Basic routing rule for MVP:
  // < 5000 => manager; >= 5000 => finance
  if (Number(amount) < 5000) return 'manager';
  return 'finance';
};

export const uploadInvoice = async (req, res) => {
  try {
    const { amount, currency, vendor, dueDate, note, fileUrl } = req.body;
    if (!amount) return res.status(400).json({ error: 'Amount is required' });

    const invoice = await createInvoice({
      userId: req.user.id,
      amount,
      currency,
      vendor,
      dueDate,
      note,
      fileUrl
    });

    await addLog({
      invoiceId: invoice.id,
      userId: req.user.id,
      action: 'created',
      details: `Invoice created with amount ${invoice.amount} ${invoice.currency}`
    });

    const routeRole = routeByAmount(invoice.amount);
    await addLog({
      invoiceId: invoice.id,
      userId: req.user.id,
      action: 'routed',
      details: `Routed to ${routeRole}`
    });

    res.status(201).json({ invoice });
  } catch (err) {
    res.status(500).json({ error: 'Upload failed' });
  }
};

export const getStatus = async (req, res) => {
  try {
    const invoices = await getInvoicesByUser(req.user.id);
    res.json({ invoices });
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch status' });
  }
};

export const approveOrReject = async (req, res) => {
  try {
    const { invoiceId, decision } = req.body; // decision: 'approve' | 'reject'
    if (!invoiceId || !decision) return res.status(400).json({ error: 'Missing fields' });

    const invoice = await getInvoiceById(invoiceId);
    if (!invoice) return res.status(404).json({ error: 'Invoice not found' });

    // Simple role gate: manager can approve < 5000, finance can approve >= 5000
    const isManager = req.user.role === 'manager';
    const isFinance = req.user.role === 'finance';
    const amount = Number(invoice.amount);

    if (decision === 'approve') {
      if ((amount < 5000 && !isManager) || (amount >= 5000 && !isFinance)) {
        return res.status(403).json({ error: 'Insufficient privileges to approve' });
      }
      const updated = await updateInvoiceStatus({
        id: invoiceId,
        status: 'approved',
        approverId: req.user.id
      });
      await addLog({
        invoiceId,
        userId: req. user.id,
        action: 'approved',
        details: `Approved by ${req.user.role}`
      });
      return res.json({ invoice: updated });
    }

    if (decision === 'reject') {
      const updated = await updateInvoiceStatus({
        id: invoiceId,
        status: 'rejected',
        approverId: req.user.id
      });
      await addLog({
        invoiceId,
        userId: req.user.id,
        action: 'rejected',
        details: `Rejected by ${req.user.role}`
      });
      return res.json({ invoice: updated });
    }

    res.status(400).json({ error: 'Invalid decision' });
  } catch (err) {
    res.status(500).json({ error: 'Approval failed' });
  }
};import { query } from '../db.js';

export const getBasicReport = async (req, res) => {
  try {
    const { rows: kpis } = await query(
      `SELECT
         COUNT(*) FILTER (WHERE status='submitted') AS submitted,
         COUNT(*) FILTER (WHERE status='approved') AS approved,
         COUNT(*) FILTER (WHERE status='rejected') AS rejected,
         AVG(EXTRACT(EPOCH FROM (updated_at - created_at)))/3600 AS avg_hours_to_update
       FROM invoices
       WHERE user_id=$1`,
      [req.user.id]
    );

    const { rows: blockers } = await query(
      `SELECT approver_id, COUNT(*) AS pending_count
       FROM invoices
       WHERE status='under_review' AND user_id=$1
       GROUP BY approver_id
       ORDER BY pending_count DESC
       LIMIT 5`,
      [req.user.id]
    );

    res.json({ kpis: kpis[0], blockers });
  } catch (err) {
    res.status(500).json({ error: 'Report failed' });
  }
};
import { Router } from 'express';
import { login, register } from '../controllers/authController.js';

const router = Router();

router.post('/register', register);
router.post('/login', login);

export default router;
import { Router } from 'express';
import { requireAuth } from '../middleware/auth.js';
import { uploadInvoice, getStatus, approveOrReject } from '../controllers/invoiceController.js';

const router = Router();

// POST /upload
router.post('/upload', requireAuth(), uploadInvoice);

// GET /status
router.get('/status', requireAuth(), getStatus);

// POST /approve
router.post('/approve', requireAuth(['manager', 'finance']), approveOrReject);

export default router;
import { Router } from 'express';
import { requireAuth } from '../middleware/auth.js';
import { getBasicReport } from '../controllers/reportController.js';

const router = Router();

// GET /report
router.get('/report', requireAuth(), getBasicReport);

export default router;

